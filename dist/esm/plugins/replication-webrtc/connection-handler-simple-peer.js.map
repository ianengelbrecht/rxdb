{"version":3,"file":"connection-handler-simple-peer.js","names":["Subject","getFromMapOrThrow","PROMISE_RESOLVE_VOID","randomCouchString","default","Peer","newRxError","getConnectionHandlerSimplePeer","serverUrl","wrtc","creator","options","io","socket","peerId","emit","room","topic","connect$","disconnect$","message$","response$","error$","peers","Map","on","roomPeerIds","forEach","remotePeerId","has","newPeer","initiator","trickle","set","messageOrResponse","JSON","parse","toString","result","next","peer","response","message","signal","from","to","error","data","handler","send","stringify","destroy","close","complete"],"sources":["../../../../src/plugins/replication-webrtc/connection-handler-simple-peer.ts"],"sourcesContent":["import { Subject } from 'rxjs';\nimport {\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../../plugins/utils/index.ts';\nimport type {\n    WebRTCConnectionHandler,\n    WebRTCConnectionHandlerCreator,\n    WebRTCMessage,\n    WebRTCPeer,\n    PeerWithMessage,\n    PeerWithResponse\n} from './webrtc-types.ts';\n\nimport {\n    Instance as SimplePeer,\n    default as Peer\n} from 'simple-peer';\nimport type { RxError, RxTypeError } from '../../types/index.d.ts';\nimport { newRxError } from '../../rx-error.ts';\n\n/**\n * Returns a connection handler that uses simple-peer and the signaling server.\n */\nexport function getConnectionHandlerSimplePeer(\n    serverUrl: string,\n    wrtc?: any\n): WebRTCConnectionHandlerCreator {\n\n\n    const creator: WebRTCConnectionHandlerCreator = async (options) => {\n        const { io } = await import('socket.io-client');\n        const socket = io(serverUrl);\n\n        const peerId = randomCouchString(10);\n        socket.emit('join', {\n            room: options.topic,\n            peerId\n        });\n\n        const connect$ = new Subject<WebRTCPeer>();\n        const disconnect$ = new Subject<WebRTCPeer>();\n        const message$ = new Subject<PeerWithMessage>();\n        const response$ = new Subject<PeerWithResponse>();\n        const error$ = new Subject<RxError | RxTypeError>();\n\n        const peers = new Map<string, SimplePeer>();\n\n        socket.on('joined', (roomPeerIds: string[]) => {\n            roomPeerIds.forEach(remotePeerId => {\n                if (\n                    remotePeerId === peerId ||\n                    peers.has(remotePeerId)\n                ) {\n                    return;\n                }\n                // console.log('other user joined room ' + remotePeerId);\n                const newPeer: SimplePeer = new Peer({\n                    initiator: remotePeerId > peerId,\n                    wrtc,\n                    trickle: true\n                }) as any;\n                peers.set(remotePeerId, newPeer);\n\n\n                newPeer.on('data', (messageOrResponse: any) => {\n                    messageOrResponse = JSON.parse(messageOrResponse.toString());\n                    // console.log('got a message from peer3: ' + messageOrResponse)\n                    if (messageOrResponse.result) {\n                        response$.next({\n                            peer: newPeer as any,\n                            response: messageOrResponse\n                        });\n                    } else {\n                        message$.next({\n                            peer: newPeer as any,\n                            message: messageOrResponse\n                        });\n                    }\n                });\n\n                newPeer.on('signal', (signal: any) => {\n                    // console.log('emit signal from ' + peerId + ' to ' + remotePeerId);\n                    socket.emit('signal', {\n                        from: peerId,\n                        to: remotePeerId,\n                        room: options.topic,\n                        signal\n                    });\n                });\n\n                newPeer.on('error', (error) => {\n                    error$.next(newRxError('RC_WEBRTC_PEER', {\n                        error\n                    }));\n                });\n\n                newPeer.on('connect', () => {\n                    connect$.next(newPeer as any);\n                });\n\n            });\n        });\n\n        socket.on('signal', (data: any) => {\n            // console.log('got signal(' + peerId + ') ' + data.from + ' -> ' + data.to);\n            const peer = getFromMapOrThrow(peers, data.from);\n            peer.signal(data.signal);\n        });\n\n        const handler: WebRTCConnectionHandler = {\n            error$,\n            connect$,\n            disconnect$,\n            message$,\n            response$,\n            async send(peer: WebRTCPeer, message: WebRTCMessage) {\n                await (peer as any).send(JSON.stringify(message));\n            },\n            destroy() {\n                socket.close();\n                error$.complete();\n                connect$.complete();\n                disconnect$.complete();\n                message$.complete();\n                response$.complete();\n                return PROMISE_RESOLVE_VOID;\n            }\n        };\n        return handler;\n    };\n    return creator;\n}\n"],"mappings":"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"}